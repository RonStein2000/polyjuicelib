{
  "name": "Polyjuicelib",
  "tagline": "Library that takes js and applies it to the given JSON object from the JVM",
  "body": "## Polyjuice library for mapping JSON objects with dynamic JavaScript code in Scala\r\n\r\n### What it does\r\n```\r\n                                       +----------------+\r\n                                       |                |\r\n                                       | Dynamic        |\r\n                                       | JavaScript code|\r\n                                       |       +        |\r\n                                       +-------|--------+\r\n                                               |\r\n                                               |\r\n                                               |\r\n                                               v\r\n         +------------+                +---------------+                +-------------+\r\n   JVM   |            |                |               |  mapped object |             |      JVM\r\n+-object---> Json4s  +--object as JSON --> Polyjuice +----------by------->  Json4s   +--mapped object->\r\n         | serialize  |                |               |  given js code | Deserialize |\r\n         |            |                |               |     as JSON    |             |\r\n         +------------+                +---------------+                +-------------+\r\n\r\n```\r\n \r\n### Why it was build\r\nLet's say you have an expense report which is modeled something like this\r\n```scala\r\ncase class Report(createdAt: Option[LocalDateTime], currency: Currency, amount: Double, country: Option[String], customFields: Map[String,CustomField]) \r\n```                        \r\nHere at VATBox we are dealing with a lot of Reports (no they don't look like this unfortunately), each one of them have different custom fields which is customer depending.\r\nFor example one customer can have a custom field called \"center\" with ~20 different values one for each country it has a subsidiary in.\r\nSince each \"center\" is in a different country there are different rules hence we need to __map__ each report by different custom fields with countries etc.\r\n\r\n*This way we can write customer's report specific mapping code and just \"upload\" it to an already running applications without having them altered for this.*  \r\n \r\n### Features\r\n* [Nashorn](http://www.oracle.com/technetwork/articles/java/jf14-nashorn-2126515.html) \r\n* Supports 'primitive' types or your own custom models via [Json4s](https://github.com/json4s/json4s)\r\n* Malicious code safety (endless loops, external libraries, native code)  \r\n\r\n### Examples\r\nThere are more examples in [Tests](/src/test/scala/com/vatbox/polyjuice/PolyjuiceSpec.scala)\r\n* Return a String value of the \"name\" key\r\n```scala\r\n\"Return String\" in {\r\n        val mapper = Polyjuice.createMapper(varName = \"report\", userCode = s\"\"\"return report.name;\"\"\")\r\n        val triedT = mapper.map[String](s\"\"\"{\"name\" : \"hello World\"}\"\"\")\r\n        triedT.futureValue.value shouldBe \"hello World\"\r\n      }\r\n```\r\n* Return an Int\r\n```scala\r\n\"Return Int\" in {\r\n        val mapper = Polyjuice.createMapper(\"expense\", s\"\"\"if (expense.expense > 400) {return 1;} else {return 2;}\"\"\")\r\n        val triedT = mapper.map[Int](s\"\"\"{\"expense\" : 500}\"\"\")\r\n        triedT.futureValue.value shouldBe 1\r\n      }\r\n```\r\n* Return a Double (well you got the idea)\r\n```scala\r\n\"Return Double\" in {\r\n        val mapper = Polyjuice.createMapper(\"unused\", s\"\"\"return 3.3;\"\"\")\r\n        val triedT = mapper.map[Double](s\"\"\"{\"irrelevant\" : 500}\"\"\")\r\n        triedT.futureValue.value shouldBe 3.3\r\n      }\r\n```\r\n* Return a LocalDateTime\r\n```scala\r\n\"Return Date as LocalDateTime\" in {\r\n        val mapper = Polyjuice.createMapper(\"unused\", s\"\"\"return new Date();\"\"\")\r\n        val triedT = mapper.map[LocalDateTime](s\"\"\"{\"irrelevant\" : 500}\"\"\")\r\n        triedT.futureValue.value shouldBe a [LocalDateTime]\r\n      }\r\n```\r\n* Now return that same Date but now as [8601](https://en.wikipedia.org/wiki/ISO_8601) String\r\n```scala\r\n\"Return Date as String\" in {\r\n        val mapper = Polyjuice.createMapper(\"unused\", s\"\"\"return new Date();\"\"\")\r\n        val triedT = mapper.map[String](s\"\"\"{\"irrelevant\" : 500}\"\"\")\r\n        triedT.futureValue.value shouldBe a [String]\r\n        // 2016-10-19T10:07:05.427Z\r\n      }\r\n```\r\n* Return a custom object\r\n```scala \r\ncase class SimpleTestModel(name: String, value: Int)\r\n```\r\n```scala\r\n\"Return Object as Object\" in {\r\n        val mapper = Polyjuice.createMapper(\"report\", s\"\"\"return {name: report.firstName, value : 5};\"\"\")\r\n        val triedT = mapper.map[SimpleTestModel](s\"\"\"{\"firstName\" : \"Cool\"}\"\"\")\r\n        triedT.futureValue.value shouldBe SimpleTestModel(\"Cool\", 5)\r\n      }\r\n```\r\n\r\n### Safety part - endless loop\r\n```scala\r\n    \"Infinite loop\" in {\r\n      val mapper = Polyjuice.createMapper(\"whatever\",\r\n        s\"\"\"\r\n           |while(true){\r\n           |}\"\"\".stripMargin)\r\n      val triedT = mapper.map(jsonObject = s\"\"\"{ \"name\" : \"somename\" }\"\"\", timeout = 3 seconds)\r\n      triedT.failed.futureValue shouldBe a [TimedoutExecution]\r\n    }\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}